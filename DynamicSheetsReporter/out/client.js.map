{"version":3,"file":"client.js","mappings":";;;;;;;AAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,8CAA8C,GAAG;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,sBAAsB;AACvF;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,gBAAgB;AACnF;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB,cAAc;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA,kDAAkD,EAAE;AACpD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,EAAE;AACjD;AACA;AACA,KAAK;AACL;AACA","sources":["webpack://ClientBundle/./src/client/main.ts"],"sourcesContent":["\"use strict\";\n// Client bootstrap: Promise wrapper for google.script.run and simple UI wiring\nfunction run(funcName, ...args) {\n    return new Promise((resolve, reject) => {\n        // eslint-disable-next-line no-undef\n        google.script.run\n            .withSuccessHandler((res) => resolve(res))\n            .withFailureHandler((err) => reject(err))[funcName](...args);\n    });\n}\nfunction byId(id) {\n    const el = document.getElementById(id);\n    if (!el)\n        throw new Error(`element not found: ${id}`);\n    return el;\n}\nasync function init() {\n    const apiKeyInput = byId('apiKey');\n    const apiKeyMasked = byId('apiKeyMasked');\n    const modelSel = byId('model');\n    const localeInput = byId('locale');\n    const tzInput = byId('tz');\n    const saveBtn = byId('saveBtn');\n    const saveStatus = byId('saveStatus');\n    const pingBtn = byId('pingBtn');\n    const pingResult = byId('pingResult');\n    // Gemini minimal test UI\n    let gemBtn = null;\n    let gemPrompt = null;\n    let gemResult = null;\n    try {\n        gemBtn = byId('gemBtn');\n        gemPrompt = byId('gemPrompt');\n        gemResult = byId('gemResult');\n    }\n    catch (_) {\n        // optional section not present\n    }\n    // load current settings\n    try {\n        const settings = await run('getUserSettings');\n        apiKeyMasked.textContent = settings.hasApiKey ? `保存済み: ${settings.apiKeyMasked}` : '未保存';\n        modelSel.value = settings.model;\n        localeInput.value = settings.locale || 'ja-JP';\n        tzInput.value = settings.timezone || 'Asia/Tokyo';\n    }\n    catch (e) {\n        saveStatus.textContent = `設定の取得に失敗しました: ${e}`;\n        saveStatus.className = 'error';\n    }\n    saveBtn.addEventListener('click', async () => {\n        try {\n            saveBtn.disabled = true;\n            saveStatus.textContent = '保存中...';\n            const req = {\n                model: modelSel.value,\n                locale: localeInput.value,\n                timezone: tzInput.value,\n            };\n            if (apiKeyInput.value && apiKeyInput.value.trim().length > 0) {\n                req.apiKeyPlain = apiKeyInput.value.trim();\n            }\n            const res = await run('saveUserSettings', req);\n            if (res.ok) {\n                saveStatus.textContent = '保存しました';\n                saveStatus.className = 'ok';\n                const st = res.settings;\n                apiKeyMasked.textContent = st.hasApiKey ? `保存済み: ${st.apiKeyMasked}` : '未保存';\n                apiKeyInput.value = '';\n            }\n            else {\n                saveStatus.textContent = `保存に失敗: ${res.error}`;\n                saveStatus.className = 'error';\n            }\n        }\n        catch (e) {\n            saveStatus.textContent = `保存中にエラー: ${e}`;\n            saveStatus.className = 'error';\n        }\n        finally {\n            saveBtn.disabled = false;\n        }\n    });\n    if (gemBtn && gemPrompt && gemResult) {\n        gemBtn.addEventListener('click', async () => {\n            const prompt = gemPrompt.value || 'こんにちは';\n            gemResult.textContent = '生成中...';\n            gemResult.className = 'mono';\n            try {\n                const req = {\n                    model: byId('model').value || 'gemini-2.5-flash',\n                    contents: [\n                        { role: 'user', parts: [{ text: prompt }] }\n                    ]\n                };\n                const res = await run('generateContentProxy', req);\n                if (res.ok) {\n                    gemResult.textContent = res.text || '(empty)';\n                    gemResult.className = 'ok mono';\n                }\n                else {\n                    gemResult.textContent = `error: ${res.error}`;\n                    gemResult.className = 'error mono';\n                }\n            }\n            catch (e) {\n                gemResult.textContent = `error: ${e}`;\n                gemResult.className = 'error mono';\n            }\n        });\n    }\n    pingBtn.addEventListener('click', async () => {\n        pingResult.textContent = 'ping...';\n        try {\n            const res = await run('ping');\n            pingResult.textContent = res;\n            pingResult.className = 'ok mono';\n        }\n        catch (e) {\n            pingResult.textContent = `error: ${e}`;\n            pingResult.className = 'error mono';\n        }\n    });\n}\ndocument.addEventListener('DOMContentLoaded', init);\n"],"names":[],"sourceRoot":""}