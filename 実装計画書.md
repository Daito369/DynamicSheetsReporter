# **【改訂版】実装計画書：Dynamic Sheets Reporter v2.0**

## **1. ビジョンと戦略：対話型アナリティクスハブの構築**

### **1.1. エグゼクティブサマリー**

本ドキュメントは、前回の計画を大幅に拡張・深化させた「Dynamic Sheets Reporter v2.0」の最終実装計画書です。本ツールは、Google Workspace環境内に閉じたサーバーレスアーキテクチャを維持しつつ、その機能を**「静的なレポートツール」から「動的な対話型分析プラットフォーム」**へと進化させます。

v2.0の核心は、以下の3つの戦略的ピラーによって支えられます：

1. **対話型インターフェース (Conversational Interface):** ユーザーは自然言語でデータに問いかけ、AIがそれを解釈して分析を実行します。これにより、UI操作の壁を取り払い、思考の速度でデータ探索を可能にします。
2. **プロアクティブ・インサイト (Proactive Insights):** AIが単に結果を表示するだけでなく、データに潜む傾向や異常値を自律的に発見し、ユーザーに「次の質問」を提案します。ツールがユーザーの分析パートナーとなります。
3. **インテリジェンスの拡張性 (Intelligence Scalability):** Google Colabとの連携により、GASの実行環境だけでは不可能な高度な統計分析や機械学習モデル（需要予測、異常検知など）を実行可能にします。さらに、Lookerへの「卒業パス」を提供し、アドホックな分析から統制されたエンタープライズBIへの橋渡しを実現します。

これらの機能拡張は、GCP利用不可という制約を遵守しつつ、Google Workspaceが提供するツール群（GAS, Gemini, Colab, Looker）を最大限に活用することで実現します。

### **1.2. アーキテクチャの進化：インテリジェンス層の強化**

基本的な3層アーキテクチャ（フロントエンド、バックエンド、Googleサービス）は維持しつつ、各層の連携をより高度化させます。特に、Google Colabを非同期の高度分析エンジンとして組み込むことで、システムの処理能力を飛躍的に向上させます。

*図：v2.0 高度分析連携アーキテクチャ*

**コード スニペット**

`graph TD
    subgraph User Browser (Vue.js SPA)
        A[UI: 自然言語クエリ入力]
        B[UI: 高度分析実行ボタン]
        C[UI: 結果表示 (表, チャート, AIインサイト)]
    end

    subgraph Google Apps Script (Backend)
        D[main.ts: doGet, APIエンドポイント]
        E
        F
        G
    end

    subgraph Google Services
        H
        I[Gemini API]
        J
        K
    end

    A -- google.script.run --> E
    B -- google.script.run --> G
    E -- SpreadsheetApp --> H
    E -- UrlFetchApp (Gemini) --> I
    F -- UrlFetchApp (Gemini) --> I
    G -- DriveApp --> J
    J -- File Trigger (Polling) --> K
    K -- Python Libraries (pandas, scikit-learn) --> K
    K -- gspread/dfs --> H
    D -- HtmlService --> C`

## **2. UI/UXの飛躍的向上：「超絶イケてる」体験の実現**

### **2.1. コア体験の再定義：AIとの対話**

- **自然言語クエリ:** ユーザーは固定のフィルターUIだけでなく、自由なテキスト入力で分析を指示できます。「先月の製品カテゴリ'Video'に関するケースで、担当者ごとの平均解決時間を表示して」といった曖昧な指示を、バックエンドの`QueryService`がGemini APIに送信します。Geminiは、事前にキャッシュされたシートのスキーマ情報（列名、データ型）をコンテキストとして与えられ、この自然言語を構造化されたJSONクエリオブジェクトに変換します。
- **プロアクティブな分析提案:** データが表示された後、`InsightService`が結果データをGeminiに送信し、「このデータから読み取れる興味深い傾向、外れ値、または相関関係を3つ指摘し、それぞれについて深掘りするための次の分析アクションを提案してください」といったプロンプトを実行します。結果は「気づき」としてUIにカード形式で表示され、ユーザーはクリック一つで次の分析（例：「担当者'shimonm'のケースだけをドリルダウンする」）に進めます。

### **2.2. データ可視化の自動化**

- **インテリジェント・チャート:** 分析結果に基づき、Gemini APIに「このデータセット（列Aはカテゴリ、列Bは数値）を可視化するのに最適なグラフの種類は何ですか？（例：棒グラフ、折れ線グラフ、円グラフ）」と問い合わせます。返された推奨に基づき、フロントエンドはChart.jsなどのライブラリを用いて最適なグラフを自動的にレンダリングします。

### **2.3. 高度なデータ操作機能**

- **複数シートの横断分析（AI Join）:**
    1. ユーザーが分析対象として複数のシートを選択します。
    2. バックエンドは各シートのヘッダー情報をGeminiに送信し、「これらのシート群を結合するための最も可能性の高い共通キー（列名）を特定してください」と指示します。
    3. Geminiが返した共通キー（例：'Case ID'）をUI上でユーザーに提示し、確認を求めます。
    4. 承認後、GASバックエンドは各シートのデータをメモリに読み込み、指定されたキーで内部的に結合（JOIN）処理を行い、結合後のデータを分析対象とします。これにより、複数のファイルにまたがる正規化されたデータを一つのテーブルのように扱えます。
- **ビューの保存と共有:** ユーザーは現在のフィルター、選択列、チャートの種類などを「ビュー」として名前を付けて保存できます。このビューの状態はJSONオブジェクトとして`PropertiesService`に保存されます。UIには保存済みビューのリストが表示され、ワンクリックでいつでも呼び出せます。また、「共有リンクを取得」ボタンで、現在のビュー状態をパラメータとして含むURLを生成し、他のユーザーと共有できます。

## **3. コア機能の実装：高度分析とエンタープライズ連携**

### **3.1. Google Colab連携による高度分析ワークフロー**

GASの6分という実行時間制限と計算能力の限界を超えるため、Pythonの強力なデータサイエンスライブラリ（Pandas, Scikit-learn, TensorFlow等）を活用できるGoogle Colabを非同期処理エンジンとして統合します **1**。

**ユーザージャーニー:**

1. **分析開始 (GAS Web App):** ユーザーはUI上でデータをフィルタリングし、「Colabで需要予測を実行」のような高度分析ボタンをクリックします。
2. **ジョブの準備 (GAS Backend):**
    - `ColabOrchestratorService`が起動します。
    - フィルタリングされたデータをCSV形式で抽出し、ユーザーのGoogle Drive内の共有フォルダ（例：`/DynamicReporter/ColabJobs/Input/`）に一時的なGoogleスプレッドシートとして保存します。
    - ジョブの詳細（入力ファイルID、実行したい分析の種類、結果を書き込むシート名、ユーザーのメールアドレスなど）を記述したJSONファイル（例：`job_{timestamp}.json`）を同フォルダに作成します。
    - UIには「高度分析を実行中です。完了次第、結果シートが作成されます」というメッセージを表示します。
3. **ジョブの実行 (Google Colab):**
    - 予め用意され、時間ベースのトリガー（例：5分ごと）で定期実行されるように設定されたColabノートブックが起動します。
    - ノートブックはGoogle Driveをマウントし、`/ColabJobs/Input/`フォルダをスキャンして未処理の`job_*.json`ファイルを探します **3**。
    - ジョブファイルを見つけると、その指示に従い入力スプレッドシートをPandas DataFrameとして読み込みます。
    - 指定された高度な分析（時系列予測、クラスタリング、回帰分析など）を実行します。
    - 結果（予測データ、分析グラフ画像など）を新しいGoogleスプレッドシートに出力するか、元のスプレッドシートに新しいシートとして追記します。
4. **完了通知 (GAS Backend & Frontend):**
    - Colabは処理完了後、ジョブファイルを`/ColabJobs/Processed/`に移動させます。
    - GAS側の`ColabOrchestratorService`は、定期的なトリガー（またはユーザーがUIを再訪した際）に、元のスプレッドシートに結果シートが作成されたかを確認します。
    - 結果シートが確認でき次第、UI上でユーザーに通知を表示し、結果へのリンクを提供します。

このアーキテクチャは、GCP環境なしでGASとColabを連携させるための、現実的かつ強力なソリューションです **4**。

### **3.2. 開発者ガイドとファイル構造（v2.0）**

v1.0の推奨ワークフロー（`clasp`, TypeScript, Git）を継承しつつ、Colab連携のためのファイルを追加します **7**。

| ファイルパス | 説明 |
| --- | --- |
| ... (v1.0と同様のファイル)... |  |
| `/src/server/services/QueryService.ts` | **新規:** 自然言語クエリの解釈とデータ取得ロジックを管理。 |
| `/src/server/services/InsightService.ts` | **新規:** Geminiを用いたプロアクティブなインサイト生成を管理。 |
| `/src/server/services/ColabOrchestratorService.ts` | **新規:** Colab連携ジョブの作成と完了監視を行うサービス。 |
| `/colab/` | **新規ディレクトリ:** Colab関連ファイルを格納。 |
| `/colab/analysis_worker.ipynb` | 定期実行されるメインのColab分析ノートブック。 |
| `/colab/requirements.txt` | Colabノートブックが必要とするPythonライブラリを定義。 |

## **4. 戦略的提案：Looker連携による分析ワークフローの完成**

貴社環境でLookerが利用可能であることは、本ツールにとって大きな戦略的機会です。本ツールを、Lookerを補完し、組織全体のデータリテラシーを向上させるための強力なフロントエンドとして位置づけることを提案します。

### **提案：アドホック分析から定型ダッシュボードへの「卒業パス」**

コンセプト:

多くのビジネスユーザーにとって、公式のBIダッシュボード（Looker）は完成されたレポートを見る場所ですが、新しい切り口でデータを探索したり、仮説を検証したりする場としてはハードルが高い場合があります。

`Dynamic Sheets Reporter`は、そのギャップを埋めるための**「分析のサンドボックス」**として機能します。ユーザーはスプレッドシートを元に、自然言語で自由にデータを探索し、AIの助けを借りながら試行錯誤を繰り返します。その中で生まれた有益な分析パターンやインサイトを、**ワンクリックでLooker Studioで利用可能な形式に「卒業」させる**機能を提供します。

**具体的なワークフロー:**

1. **発見と探索 (Dynamic Sheets Reporter):** ユーザーは本ツールを使い、複数シートの結合やAIインサイト機能を駆使して、価値あるデータの切り口（例：特定の製品カテゴリと顧客セグメントを組み合わせた場合の問い合わせ傾向）を発見します。
2. **データソースの生成 (Dynamic Sheets Reporter):** ユーザーがUI上の「このビューをLooker用にエクスポート」ボタンをクリックします。
3. **自動整形 (GAS Backend):** バックエンドは、現在の分析結果（フィルタリング、結合、計算済み）を、Looker Studioがデータソースとして最も扱いやすい**クリーンで非正規化された単一のテーブル形式**を持つ新しいGoogleスプレッドシートとして生成します。ヘッダーの結合や不要なメタデータの削除も自動的に行います。
4. **ダッシュボード構築 (Looker Studio):**
    - 本ツールは、生成された新しいスプレッドシートへのリンクをユーザーに提示します。
    - 同時に、「このデータソースをLooker Studioで開く」ためのURLも生成します。これにより、ユーザーは数クリックで新しいデータソースをLooker Studioに接続できます。
    - （オプション）UI上に、Looker Studioで基本的なグラフ（本ツールで表示していたものと同様のグラフ）を作成するための簡単な手順ガイドを表示します。

**戦略的価値:**

- **ボトムアップでのBI活用促進:** 現場のユーザーが自ら発見したインサイトを起点に、公式なダッシュボードのプロトタイプを迅速に作成できます。これにより、トップダウンで提供されるのを待つだけでなく、現場主導でのデータ活用が活性化します。
- **データガバナンスの維持:** Lookerで利用するデータソースが、アドホックな分析に使われた元の乱雑なシートではなく、本ツールによって一度クレンジング・整形されたシートになるため、データソースの品質と一貫性が向上します。
- **ツールの棲み分け:** `Dynamic Sheets Reporter`は「発見と探索」に、Lookerは「定型化されたモニタリングと共有」に特化するという、理想的なツールのエコシステムを構築します。

この連携により、`Dynamic Sheets Reporter`は単体で完結するツールではなく、組織全体のデータ分析ワークフローにおいて不可欠なハブとしての地位を確立します。
## 5. 前提・制約と準拠方針（v2.0最終）

- 配布範囲: Google Workspace ドメイン内限定（appsscript.json の access = DOMAIN を堅持）。実行は「ウェブアプリにアクセスしているユーザー」(executeAs USER_ACCESSING)。
- 対象ユーザー: 認証済みの Ldap@google.com ユーザーのみを想定（ドメイン範囲でのアクセス制御）。
- Gemini モデルとエンドポイント:
  - モデル選択肢: gemini-2.5-pro / gemini-2.5-flash / gemini-2.5-flash-lite
  - 認証: Google AI Studio の API キー（ユーザー毎に PropertiesService.getUserProperties() で保管）
  - REST エンドポイント: POST https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent
  - Authorization: Bearer {API_KEY} または key= クエリパラメータ（推奨は Authorization ヘッダ）
  - Content-Type: application/json
- Colab 時間トリガー: 標準 10 分間隔（Drive ポーリング + 冪等処理 + 同時実行制御 + 指数バックオフ）
- Looker エクスポート: 命名規約 DSR_Export_{YYYYMMDD_HHmm}_v{n}、タイムゾーン Asia/Tokyo 固定

## 6. 完成版 アーキテクチャ図（差し替え）

```mermaid
graph TD
  subgraph "ユーザーブラウザ (Vue 3 SPA)"
    UIQ[自然言語クエリ入力]
    UIC[結果表示: テーブル/チャート/インサイト]
    UIS[設定(鍵/モデル)]
    UICB[Colab高度分析実行]
  end

  subgraph "Google Apps Script (Backend / API Layer)"
    M[main.ts doGet/ルーティング]
    C1[UserSettingsController]
    C2[QueryController]
    C3[InsightController]
    C4[ColabController]
    C5[ViewController]
    S1[GeminiService]
    S2[QueryService]
    S3[InsightService]
    S4[ColabOrchestratorService]
    S5[SchemaService/Cache]
    S6[ValidationService]
    Lg[LoggingService]
  end

  subgraph "Google Services"
    PS[(PropertiesService User)]
    SH[(Google Sheets)]
    DR[(Google Drive)]
    CL[(Google Colab Notebook)]
    AI[(Gemini API v1beta)]
  end

  UIQ -- google.script.run --> C2
  UIS -- google.script.run --> C1
  UICB -- google.script.run --> C4
  M --> C1
  M --> C2
  M --> C3
  M --> C4
  M --> C5

  C1 <---> PS
  C2 --> S5
  C2 --> S6
  C2 --> SH
  C2 --> S1
  C3 --> S1
  C4 --> DR
  C4 --> PS
  S4 -.監視/完了検知.-> DR

  S1 --> AI
  CL -.10分ポーリング.-> DR
  CL --> SH

  M -- HtmlService --> UIQ
  M -- HtmlService --> UIC
  M -- HtmlService --> UIS
```

## 7. フロントエンド実装計画（HtmlService内 SPA 最適化）

- ビルド/配信
  - webpack + TypeScript + Vue 3。chunk 分割（vendor/app）、ファイル名に content hash 付与
  - HtmlService 側は index.html を no-cache、静的アセットはキャッシュ可能に（クエリで bust）
- デザインシステム/アクセシビリティ
  - デザイントークン（color scale, spacing, radius, elevation）
  - コンポーネント: AppShell, QueryInput, DataTable(仮想スクロール), InsightCards, ChartPanel, SettingsModal, ColabJobBanner
  - キーボード操作/フォーカス管理、コントラスト比、ARIA 属性、国際化 i18n（ja 既定）
- パフォーマンス
  - 仮想スクロール（>10k 行）・差分レンダリング・スケルトンスクリーン
  - ストア（Pinia など）で result/insights/view を正規化
- RPC ラッパ
  - google.script.run を Promise 化し型を付与。タイムアウト/再試行（指数バックオフ）・ErrorCode 正規化
- エラーハンドリング/UX
  - ユーザー鍵未設定ガード、権限エラー提示、Colab 実行中の非同期バナー、通知トースト

## 8. バックエンド実装計画

- 構成
  - controllers: UserSettings, Query, Insight, Colab, View
  - services: Gemini, Query, Insight, ColabOrchestrator, Schema(cache), Validation, Logging
  - utils: ScriptRunPromise, RateLimiter, Time
  - common: interfaces, errors, constants
- スキーマ推定とキャッシュ
  - 先頭行ヘッダ、数行サンプルから型推定。ユーザー毎/シート毎キャッシュ（CacheService または PropertiesService user-scope キー短期保存）
- 集計エンジン（GAS）
  - StructuredQuery に基づくフィルタ（演算子: equals, contains, gt/lt, last_n_days/last_month）、集計（sum/avg/count/min/max）、join はメモリ結合（キー一致）
  - 実行時間ガード（Utilities.getUuid() でトレース、6 分上限前の早期 abort と Colab 推奨）
- GeminiService（AI Studio v1beta）
  - URL: https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent
  - ヘッダ: Authorization: Bearer {API_KEY}, Content-Type: application/json
  - 生成種別: テキスト（自然言語→StructuredQuery）、インサイト、チャート推奨
  - リトライ: 429/5xx は指数バックオフ（200ms→3s、最大3回）、クォータ超過はユーザーに通知
  - 応答検証: ValidationService で JSON スキーマ検証、未知フィールド拒否
- ValidationService
  - StructuredQuery, ViewDefinition, ColabJobRequest の厳格検証
- Logging/メトリクス
  - console.log にトレースID, userEmail, action, latency(ms), outcome を構造化出力
  - 個人データは原則マスク（列名のみ、サンプル値は記録しない）

## 9. Colab オーケストレーション（運用仕様）

- ディレクトリ構成（ユーザー Drive 直下に作成）
  - /DynamicReporter/
    - /ColabJobs/
      - /Input/
      - /Processed/
      - /Failed/
- ジョブ ID / 命名
  - jobId = DSR_{yyyyMMdd_HHmmss}_{rand6}
  - job ファイル: job_{jobId}.json、入力: input_{jobId}.csv
- ジョブ JSON スキーマ（ColabJobRequest）
```json
{
  "jobId": "DSR_20250807_123000_AB12CD",
  "userEmail": "user@google.com",
  "analysisType": "forecast|clustering|regression|custom",
  "inputSheetId": "spreadsheetId",
  "inputSheetName": "FilteredInput",
  "inputCsvFileId": "driveFileId",
  "params": { "horizon": 12, "frequency": "M" },
  "output": {
    "targetSpreadsheetId": "spreadsheetId",
    "resultSheetName": "Forecast_2025Q1",
    "writeMode": "append|replace"
  },
  "createdAt": "2025-08-07T03:21:00Z",
  "expiresAt": "2025-08-07T06:21:00Z",
  "retries": 0
}
```
- 冪等/重複排除
  - 同一 jobId の重複は Colab 側でスキップ（Processed/Failed に既存あれば再処理しない）
- 同時実行制御
  - Colab ノートブック側で同時処理 N=1..3、キューリングはファイル順
- リトライ/バックオフ
  - 一時エラーは指数バックオフで最大 3 回、失敗は /Failed/ に移動し reason を JSON 追記
- 監査ログ
  - 各状態遷移をログ（検出→処理中→書込→完了/失敗）
- セキュリティ
  - ノートブックはユーザー自身の OAuth で gspread/Drive/Sheets にアクセス（共有フォルダは対象ユーザーに編集付与）

## 10. Looker エクスポート仕様（必須）

- 目的: Looker Studio が扱いやすい「クリーンで非正規化単一表」を生成
- 命名/配置
  - 新規スプレッドシートまたは既存への新シート名: DSR_Export_{YYYYMMDD_HHmm}_v{n}
  - タイムゾーン: Asia/Tokyo、日付列は YYYY-MM-DD、日時列は RFC3339（ローカル表示はシートのタイムゾーンで制御）
- データ規約
  - 1行目ヘッダは英数字と_のみ、空白・絵文字禁止
  - 数値列は数値型整形、ブールは TRUE/FALSE、カテゴリは string
  - NULL は空セル（必要に応じ 'N/A' ではなく空）
- 付帯情報
  - メタデータシート _meta を追加（作成者, 作成時刻, 元クエリ, 行数, バージョン）
- 導線
  - 生成後に UI へ「Looker Studio で開く」リンクを提示（Looker データソース作成 URL を案内）

## 11. API / データモデル（完全定義）

```typescript
// UserSettings
export interface UserSettings {
  apiKey?: string; // AI Studio API Key
  model?: 'gemini-2.5-pro' | 'gemini-2.5-flash' | 'gemini-2.5-flash-lite';
}

// ViewDefinition
export interface ViewDefinition {
  id: string;
  name: string;
  spreadsheetId: string;
  sheetName: string;
  query: StructuredQuery;
  chart?: { type: 'bar'|'line'|'pie'|'scatter'; options?: any };
  createdAt: string;
  updatedAt: string;
}

// ColabJobRequest / JobStatus
export interface ColabJobRequest {
  jobId: string;
  userEmail: string;
  analysisType: 'forecast'|'clustering'|'regression'|'custom';
  inputSheetId: string;
  inputSheetName: string;
  inputCsvFileId: string;
  params?: any;
  output: { targetSpreadsheetId: string; resultSheetName: string; writeMode: 'append'|'replace' };
  createdAt: string;
  expiresAt?: string;
  retries?: number;
}

export interface JobStatus {
  jobId: string;
  state: 'queued'|'running'|'completed'|'failed';
  message?: string;
  resultSheetId?: string;
  updatedAt: string;
}
```

## 12. サンプルコード（抜粋）

- Gemini 呼び出し例（Apps Script）
```typescript
// /src/server/services/GeminiService.ts
function generateContent_(apiKey: string, model: string, contents: any): string {
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
  const payload = JSON.stringify({ contents }); // {contents:[{role:'user',parts:[{text:'...'}]}]}
  const res = UrlFetchApp.fetch(url, {
    method: 'post',
    contentType: 'application/json',
    headers: { Authorization: `Bearer ${apiKey}` },
    payload,
    muteHttpExceptions: true,
  });
  const code = res.getResponseCode();
  const body = res.getContentText();
  if (code === 429 || code >= 500) {
    throw new Error(`RETRYABLE:${code}:${body}`);
  }
  if (code >= 400) {
    throw new Error(`NON_RETRYABLE:${code}:${body}`);
  }
  return body; // 応答の parsing は呼び出し側で実施
}
```

- google.script.run Promise ラッパ
```typescript
// /src/client/services/ApiClient.ts
export function run<T>(funcName: string, ...args: any[]): Promise<T> {
  return new Promise((resolve, reject) => {
    // @ts-ignore
    google.script.run
      .withSuccessHandler((res: T) => resolve(res))
      .withFailureHandler((err: any) => reject(err))
      [funcName](...args);
  });
}
```

- StructuredQuery バリデーション（概略）
```typescript
// /src/server/services/ValidationService.ts
export function validateStructuredQuery(q: any): asserts q is StructuredQuery {
  const required = Array.isArray(q.dimensions) && Array.isArray(q.metrics) && Array.isArray(q.filters);
  if (!required) throw new Error('Invalid StructuredQuery');
  // 追加: 型/演算子/フィールド存在チェック
}
```

- Colab ジョブ作成（GAS 側）
```typescript
// /src/server/services/ColabOrchestratorService.ts
function createColabJob_(req: ColabJobRequest): JobStatus {
  const folder = ensureFolders_(); // /DynamicReporter/ColabJobs/Input
  const jobFile = DriveApp.createFile(`job_${req.jobId}.json`, JSON.stringify(req), 'application/json');
  folder.addFile(jobFile);
  return { jobId: req.jobId, state: 'queued', updatedAt: new Date().toISOString() };
}
```

## 13. 運用: ロギング/メトリクス/SLO/ランブック

- 目標値（SLO）
  - クエリ実行の p95 レイテンシ < 4.0s（GAS）
  - Colab ジョブの p95 完了時間 < 30 分
  - エラー率 < 1.0%
- 監視対象
  - クエリ件数/失敗率、Gemini 呼び出し 429/5xx 率、Colab 失敗件数、Looker エクスポート成功率
- インシデント対応
  - 429 過多 → レート低減/モデル切替（flash/flash-lite）
  - Colab 失敗 → /Failed/ フォルダの reason を確認、再投入手順記載
- ロールバック
  - clasp で直前バージョンへデプロイ差し戻し、appsscript.json の access/executeAs を確認

## 14. デプロイ/設定チェックリスト

- appsscript.json
  - timeZone, runtimeVersion = V8、exceptionLogging = STACKDRIVER
  - webapp.executeAs = USER_ACCESSING、webapp.access = DOMAIN
  - oauthScopes は最小限（spreadsheets, drive, external_request, userinfo.email, script.container.ui）
- デプロイ手順
  - npm run build → clasp push → 新しいデプロイ → ウェブアプリ設定（上記） → 動作確認
- 初期設定
  - 設定モーダルで API キー/モデル保存、動作テスト（自然言語クエリ、インサイト、Colab キュー、Looker エクスポート）

## 15. 直近の実装タスク（移行用スプリント項目）

1. /src/common/interfaces.ts に UserSettings, ViewDefinition, ColabJobRequest, JobStatus を追加
2. GeminiService v1beta 実装（generateContent 呼び出しとエラー分類/再試行）
3. ValidationService（StructuredQuery/ColabJobRequest/ViewDefinition 検証）
4. QueryService（フィルタ/集計/メモリ JOIN、スキーマ推定キャッシュ連携）
5. InsightService（インサイトプロンプト + 検証）
6. ColabOrchestratorService（ジョブJSON作成・監視）
7. ViewController/保存・取得実装（PropertiesService ユーザースコープ）
8. LookerExport ユーティリティ（命名・整形・リンク提示）
9. フロントエンド RPC クライアント + UI 骨格（AppShell, QueryInput, DataTable, ChartPanel, SettingsModal）
10. 運用ログ整備・トレースID・SLO 設定